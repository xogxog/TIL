# DP[동적 계획법] + 그리디 조금

- 피보나치 수열을 생각해보자.
    - 보통 재귀를 통해 표현, 하지만 피보나치 수열을 재귀로하는 경우 같은 연산을 반복해서 해야하는 문제가 발생
    - 그래서 생긴 것이 동적 계획법이다.



### 원리

- 처음 진행되는 연산은 기록해 두고, 이미 진행했던 연산이라면 다시 연산하는 것이 아니라 기록되어 있는 값을 가져오는 것이다.
- 문제를 풀 때 하나의 문제를 여러 하위 문제로 나누어 풀고, 그것들을 결합해서 최종 목적에 도달하느 방식의 알고리즘이다.



### 메모이제이션

- 동일한 문제를 반복해야 할 경우, 한번 계산된 결과를 저장해 두었다가 활용한ㄴ 방식으로 중복 계산을 줄이는 것을 메모이제이션이라고 한다.



### 방식

- top - down

```python
int fiboData[100] = {0,};

int fibo(int n)
{
  if (n<=2) 
    return 1;
  if (fiboData[n]==0)
    fiboData[n] = fibo(n-1) + fibo(n-2);
  return fiboData[n];
}
```

- bottom - up

```python
int fibo(int n)
{
  fibodata[0] = 0;
  fiboData[1] = 1;
  for (int i=2; i<=n; i++)
    fiboData[i] = fiboData[i - 1] + fiboData[i - 2];
  return fiboData[n];
}
```



### 장/단점

- 동적 계획법은 모든 방법을 일일이 검토하여 최적의 해를 찾아내는 방식의 알고리즘이다.
  
    여기서 그리디 알고리즘(탐욕 알고리즘)과 대비
    
    그리디 알고리즘은 모든 해를 구하지 않고 순간마다 그 순간에서의 최적의 해를 찾는 방식
    
    그리디 알고리즘은 닥치는 순간만을 고려해서 해를 구하기 때문에 도출된 값이 항상 최적의 해라고 할 수는 없다. 하지만 동적 계획법은 모든 방법을 검토해 보고 결과적으로 효율적인 값을 택한다. 그런 면에서 동적 계획법은 그리디 알고리즘에 비해 시간이 오래 걸리지만, 결과적으로는 항상 최적의 해를 구할 수 있다는 장점이 있다.
    



### 그리디 VS DP

- DP는 중복되는 서브 문제를 다룸
- 그리디는 중복되지 않는 서브 문제를 다룸

- 그리디의 대표적인 문제는 활동 선택 문제이다. - 시작시간 종료시간이 있다. 한사람이 최대한 많이 할 수 있는 액티비티의 수와 액티비티의 종류 구하기
    - 해결방법
        - 가장먼저 끝나는 활동 → 그다음 가장 빨리 시작하는 활동 → ... 반복해서 최적
- 그리디는 탐욕스러운 선택 조건, 최적 부분 구조 조건의 조건이 성립되어야 잘 작동한다.
    - 탐욕스러운 선택 ?
        - 앞의 선택이 이후의 선택에 영향을 주지 않는 조건
    - 최적 부분 구조 조건
        - 문제에 대한 최종 해결방법이 부분 문제에 대해서도 또한 최적 문제 해결 방법이다 하는 조건